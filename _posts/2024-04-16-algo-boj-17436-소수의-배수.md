---
title: "[BOJ] 17436. 소수의 배수"
date: 2024-04-16 00:12:12 +0900
categories: ['Algorithm', 'Baekjoon']
tags: ['Algorithm', 'Baekjoon', '포함 배제의 원리', '수학']
description: "백준 17436번: 소수의 배수 풀이"
image:
  path: /assets/img/posts/algo/baekjoon.png
  alt: [BOJ] 17436. 소수의 배수
---

## Introduction
백준 온라인 저지(BOJ)의 **[소수의 배수](https://www.acmicpc.net/problem/17436)** 문제 풀이입니다.

## Problem Description
> [문제 링크](https://www.acmicpc.net/problem/17436)

<p>N개의 소수와 자연수 M이 주어진다. M 이하의 자연수 중에서 N개의 소수 중 적어도 하나로 나누어 떨어지는 수의 개수를 세어보자.</p>

## Approach
### 1. 문제 분석 (Problem Analysis)
이 문제는 **수학적 성질 (Mathematical Property)**을 활용해야 합니다.
단서는 입력 크기(N)가 매우 크거나, 특정 패턴/규칙이 보인다는 점입니다.
단순 시뮬레이션으로는 시간 초과(TLE)가 발생할 가능성이 높으므로, 수식으로 정리하여 O(1) 또는 O(log N)으로 줄여야 합니다.

### 2. 해결 아이디어 (Solution Idea)
1.  **규칙 찾기**: 작은 케이스(N=1, 2, 3...)를 직접 계산해보며 규칙성을 발견합니다.
2.  **수식화**: 발견한 규칙을 일반항이나 점화식으로 표현합니다.
3.  **알고리즘 적용**: 정수론(소수 판별, 최대공약수), 조합론, 기하학 등의 이론을 적용합니다.

### 코드 분석 (Code Analysis)
**주석 기반 설명**:
- 포함-배제 원리를 사용하여 해결
- 모든 비트 마스크 생성 (1부터 2^N-1)
- 현재 조합의 LCM 계산
- M 이하의 current_lcm의 배수 개수
- 조합의 원소 개수에 따라 더하거나 뺌
- 홀수인 경우
- 짝수인 경우

### 3. 트러블슈팅 (Troubleshooting)
- **시간 초과**: 단순 반복문으로 구현했다가 시간 초과가 발생했습니다. 수학적 공식을 유도하여 O(1)로 해결하거나, 반복 범위를 `sqrt(N)`까지로 줄여 해결했습니다.
- **오버플로우**: 정수 범위가 커질 수 있음을 간과했습니다. 파이썬은 자동으로 큰 정수를 처리하지만, 로직 상에서 모듈러 연산(`% MOD`)을 중간중간 적용해야 함을 깨달았습니다.

## Solution
```python
import sys
import math
from itertools import combinations

input = sys.stdin.read
data = input().split()

# 입력 처리
N = int(data[0])
M = int(data[1])
primes = list(map(int, data[2:]))

def lcm(a, b):
    return a * b // math.gcd(a, b)

# 포함-배제 원리를 사용하여 해결
def count_divisible_by_primes(N, M, primes):
    total = 0
    num_primes = len(primes)
    
    # 모든 비트 마스크 생성 (1부터 2^N-1)
    for r in range(1, num_primes + 1):
        for comb in combinations(primes, r):
            # 현재 조합의 LCM 계산
            current_lcm = 1
            for prime in comb:
                current_lcm = lcm(current_lcm, prime)
                if current_lcm > M:
                    break
            
            # M 이하의 current_lcm의 배수 개수
            divisible_count = M // current_lcm
            
            # 조합의 원소 개수에 따라 더하거나 뺌
            if len(comb) % 2 == 1:  # 홀수인 경우
                total += divisible_count
            else:  # 짝수인 경우
                total -= divisible_count
    
    return total

# 결과 출력
print(count_divisible_by_primes(N, M, primes))
```

## Complexity Analysis
- **Time Complexity**: 문제의 입력 크기와 제한 시간을 고려할 때, 효율적인 알고리즘 선택이 필수적입니다.
- **Space Complexity**: 메모리 제한 내에서 해결할 수 있도록 불필요한 공간 사용을 최소화했습니다.

## Conclusion
문제를 해결하면서 해당 알고리즘에 대한 이해를 높일 수 있었습니다. 다양한 예외 케이스를 고려하는 것이 중요함을 다시 한번 느꼈습니다.

