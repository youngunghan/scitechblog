---
title: "[BOJ] 17436. 소수의 배수"
date: 2024-04-16 00:12:12 +0900
categories: ['Algorithm', 'Baekjoon']
tags: ['Algorithm', 'Baekjoon', '포함 배제의 원리', '수학']
description: "Solution for Baekjoon 17436: 소수의 배수"
image:
  path: /assets/img/posts/algo/baekjoon.png
  alt: [BOJ] 17436. 소수의 배수
---

## Introduction
This is a solution for **[소수의 배수](https://www.acmicpc.net/problem/17436)** on Baekjoon Online Judge.

## Problem Description
> [Problem Link](https://www.acmicpc.net/problem/17436)

<p>N개의 소수와 자연수 M이 주어진다. M 이하의 자연수 중에서 N개의 소수 중 적어도 하나로 나누어 떨어지는 수의 개수를 세어보자.</p>

## Approach
<!-- TODO: Describe your thought process here. (e.g., "At first I thought..., but...") -->
The solution uses **수학**.
See the code below for details.

## Solution
```python
import sys
import math
from itertools import combinations

input = sys.stdin.read
data = input().split()

# 입력 처리
N = int(data[0])
M = int(data[1])
primes = list(map(int, data[2:]))

def lcm(a, b):
    return a * b // math.gcd(a, b)

# 포함-배제 원리를 사용하여 해결
def count_divisible_by_primes(N, M, primes):
    total = 0
    num_primes = len(primes)
    
    # 모든 비트 마스크 생성 (1부터 2^N-1)
    for r in range(1, num_primes + 1):
        for comb in combinations(primes, r):
            # 현재 조합의 LCM 계산
            current_lcm = 1
            for prime in comb:
                current_lcm = lcm(current_lcm, prime)
                if current_lcm > M:
                    break
            
            # M 이하의 current_lcm의 배수 개수
            divisible_count = M // current_lcm
            
            # 조합의 원소 개수에 따라 더하거나 뺌
            if len(comb) % 2 == 1:  # 홀수인 경우
                total += divisible_count
            else:  # 짝수인 경우
                total -= divisible_count
    
    return total

# 결과 출력
print(count_divisible_by_primes(N, M, primes))
```

## Complexity Analysis
- **Time Complexity**: <!-- TODO: O(?) -->
- **Space Complexity**: <!-- TODO: O(?) -->

## Conclusion
<!-- TODO: Add insights or what you learned. -->
Solved successfully.

