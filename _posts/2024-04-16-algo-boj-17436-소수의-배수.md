---
title: "[BOJ] 17436. 소수의 배수"
date: 2024-04-16 00:12:12 +0900
categories: ['Algorithm', 'Baekjoon']
tags: ['Algorithm', 'Baekjoon', '포함 배제의 원리', '수학']
description: "백준 17436번: 소수의 배수 풀이"
image:
  path: assets/img/posts/algo/baekjoon.png
  alt: "[BOJ] 17436. 소수의 배수"
math: true
---

## Introduction
백준 온라인 저지(BOJ)의 **[소수의 배수](https://www.acmicpc.net/problem/17436)** 문제 풀이입니다.

## Problem Description
> [문제 링크](https://www.acmicpc.net/problem/17436)

<p>N개의 소수와 자연수 M이 주어진다. M 이하의 자연수 중에서 N개의 소수 중 적어도 하나로 나누어 떨어지는 수의 개수를 세어보자.</p>

## Approach
### 1. 문제 분석 (Problem Analysis)
이 문제는 $M$ 이하의 자연수 중에서 주어진 $N$개의 소수 중 적어도 하나로 나누어 떨어지는 수의 개수를 구하는 문제입니다.
- $N$은 최대 10, $M$은 최대 $10^{12}$입니다.
- 단순히 1부터 $M$까지 순회하며 나누어 떨어지는지 확인하는 방법은 $O(M \times N)$으로, $M$이 매우 크기 때문에 시간 초과가 발생합니다.
- 따라서 **포함-배제의 원리 (Inclusion-Exclusion Principle)**를 사용하여 효율적으로 계산해야 합니다.

### 2. 해결 아이디어 (Solution Idea)
포함-배제의 원리는 합집합의 원소 개수를 구할 때 사용됩니다.
$$ |A \cup B| = |A| + |B| - |A \cap B| $$
이를 확장하여, 여러 소수들의 배수 집합의 합집합 크기를 구합니다.

1.  **조합 생성**: $N$개의 소수 중에서 $r$개를 뽑는 모든 조합을 만듭니다 ($r = 1, \dots, N$).
2.  **LCM 계산**: 뽑힌 소수들의 최소공배수(LCM)를 구합니다. 소수들은 서로소이므로 단순히 곱하면 됩니다.
3.  **개수 계산**: $M$을 LCM으로 나눈 몫이 해당 소수들의 공배수의 개수입니다.
4.  **포함-배제 적용**:
    - 뽑은 소수의 개수($r$)가 **홀수**이면 더합니다 (+).
    - 뽑은 소수의 개수($r$)가 **짝수**이면 뺍니다 (-).

### 3. 코드 분석 (Code Analysis)
- `itertools.combinations`를 사용하여 가능한 모든 소수의 조합을 생성합니다.
- 각 조합에 대해 LCM을 계산하고, $M$보다 커지면 더 이상 계산하지 않고 중단합니다 (가지치기).
- `len(comb) % 2`를 통해 홀수/짝수 여부를 판별하고 `total`에 더하거나 뺍니다.

## Solution
```python
import sys
import math
from itertools import combinations

input = sys.stdin.read
data = input().split()

# 입력 처리
N = int(data[0])
M = int(data[1])
primes = list(map(int, data[2:]))

def lcm(a, b):
    return a * b // math.gcd(a, b)

# 포함-배제 원리를 사용하여 해결
def count_divisible_by_primes(N, M, primes):
    total = 0
    num_primes = len(primes)
    
    # 1개부터 N개까지 소수를 선택하는 모든 경우의 수 탐색
    for r in range(1, num_primes + 1):
        for comb in combinations(primes, r):
            # 현재 조합의 LCM 계산
            current_lcm = 1
            for prime in comb:
                current_lcm = lcm(current_lcm, prime)
                # LCM이 M을 초과하면 배수가 존재할 수 없으므로 중단
                if current_lcm > M:
                    break
            
            if current_lcm > M:
                continue
            
            # M 이하의 current_lcm의 배수 개수
            divisible_count = M // current_lcm
            
            # 포함-배제 원리 적용
            if len(comb) % 2 == 1:  # 홀수 개 선택: 더하기
                total += divisible_count
            else:  # 짝수 개 선택: 빼기
                total -= divisible_count
    
    return total

# 결과 출력
print(count_divisible_by_primes(N, M, primes))
```

## Complexity Analysis
- **Time Complexity**: $O(2^N \cdot N)$
    - 소수의 개수 $N$이 최대 10이므로, 부분집합의 개수는 $2^{10} = 1024$개입니다.
    - 각 부분집합에 대해 LCM을 구하는 연산은 $N$에 비례합니다.
    - $N$이 작기 때문에 충분히 시간 내에 통과합니다.
- **Space Complexity**: $O(N)$
    - 소수 리스트와 조합 생성을 위한 메모리가 필요합니다.

## Conclusion
이 문제는 포함-배제 원리의 대표적인 응용 문제입니다. $N$이 작다는 점($N \le 10$)에 착안하여 모든 조합을 탐색하는 완전 탐색 접근이 유효함을 파악하는 것이 핵심입니다.

