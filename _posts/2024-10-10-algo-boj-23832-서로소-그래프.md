---
title: "[BOJ] 23832. 서로소 그래프"
date: 2024-10-10 23:45:50 +0900
categories: ['Algorithm', 'Baekjoon']
tags: ['Algorithm', 'Baekjoon', '오일러 피 함수', '수학', '정수론']
description: "백준 23832번: 서로소 그래프 풀이"
image:
  path: /assets/img/posts/algo/math.png
  alt: [BOJ] 23832. 서로소 그래프
---

## Introduction
백준 온라인 저지(BOJ)의 **[서로소 그래프](https://www.acmicpc.net/problem/23832)** 문제 풀이입니다.

## Problem Description
> [문제 링크](https://www.acmicpc.net/problem/23832)

<p>우석이는 심심할 때마다 그래프를 그린다. 우석이는 매달 새로운 그래프를 그리는데, 이번 달에는 서로소 그래프를 그린다.</p>

<p>서로소 그래프는 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$1$</span></mjx-container>부터 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$N$</span></mjx-container>까지의 번호를 가진 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$N$</span></mjx-container> 개의 정점으로 이루어져 있으며, 서로 다른 두 정점의 번호가 서로소일 때만 두 정점이 간선 하나로 직접 연결되어 있다.</p>

<p>우석이는 간선을 얼마나 많이 그려야할지 궁금해졌다. 정점의 개수 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$N$</span></mjx-container>이 주어질 때, 만들어야 하는 간선의 개수를 알려주자.</p>

## Approach
이 문제는 **수학적 직관 (Mathematical Insight)**이 필요한 유형입니다.

단순한 시뮬레이션보다는 수식으로 정리하거나, 정수론/조합론 등의 성질을 활용하여 계산 복잡도를 줄이는 것이 핵심입니다. 문제에 주어진 수의 범위나 규칙성을 주의 깊게 관찰해야 합니다.

## Solution
```python
def count_coprime_edges(n):
    """
    Count the number of edges in the coprime graph
    """
    phi = list(range(n + 1))
    for i in range(2, n + 1):
        if phi[i] == i:
            for j in range(i, n + 1, i):
                phi[j] -= phi[j] // i
    
    return sum(phi[i] for i in range(2, n + 1))

n = int(input())
print(count_coprime_edges(n))
```

## Complexity Analysis
- **Time Complexity**: 문제의 입력 크기와 제한 시간을 고려할 때, 효율적인 알고리즘 선택이 필수적입니다.
- **Space Complexity**: 메모리 제한 내에서 해결할 수 있도록 불필요한 공간 사용을 최소화했습니다.

## Conclusion
문제를 해결하면서 해당 알고리즘에 대한 이해를 높일 수 있었습니다. 다양한 예외 케이스를 고려하는 것이 중요함을 다시 한번 느꼈습니다.

