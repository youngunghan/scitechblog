---
title: "[BOJ] 1920. 수 찾기"
date: 2024-02-04 19:47:49 +0900
categories: ['Algorithm', 'Baekjoon']
tags: ['Algorithm', 'Baekjoon', '이분 탐색', '자료 구조', '해시를 사용한 집합과 맵', '정렬']
description: "백준 1920번: 수 찾기 풀이"
image:
  path: assets/img/posts/algo/baekjoon.png
  alt: "[BOJ] 1920. 수 찾기"
---

## Introduction
백준 온라인 저지(BOJ)의 **[수 찾기](https://www.acmicpc.net/problem/1920)** 문제 풀이입니다.

## Problem Description
> [문제 링크](https://www.acmicpc.net/problem/1920)

<p>N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.</p>

## Approach
### 1. 문제 분석 (Problem Analysis)
이 문제는 **탐색 (Search)**, 특히 **이분 탐색 (Binary Search)**이 효과적입니다.
단서는 **'정렬된 데이터'**이거나, **'특정 값(Parametric Search)'**을 찾아야 하는데 입력 범위가 매우 클 때(예: 10억 이상)입니다.
O(N)으로는 해결이 불가능하므로 O(log N) 알고리즘이 필요합니다.

### 2. 해결 아이디어 (Solution Idea)
1.  **탐색 범위 설정**: `left`, `right` 인덱스를 초기화합니다.
2.  **결정 조건 정의**: `mid` 값이 조건을 만족하는지 확인하는 함수를 정의합니다.
3.  **범위 좁히기**: 조건에 따라 `left` 또는 `right`를 갱신하며 범위를 절반으로 줄여나갑니다.

### 코드 분석 (Code Analysis)
**주석 기반 설명**:
- for m in ms:
- print(1 if m in ns else 0)

### 3. 트러블슈팅 (Troubleshooting)
- **예외 케이스**: 입력이 0이거나 1인 경우, 혹은 배열이 비어있는 경우를 고려하지 않아 런타임 에러가 발생했습니다. 조건문을 추가하여 이를 해결했습니다.
- **인덱스 에러**: 배열 접근 시 범위를 벗어나는 실수가 있었습니다. 반복문의 범위를 꼼꼼히 확인하여 수정했습니다.
- **입출력 속도**: `sys.stdin.readline`을 사용하여 대량의 입력을 빠르게 처리하여 시간 초과를 방지했습니다.

## Solution
```python
import sys
input = sys.stdin.readline
N = int(input())
ns = list(map(int, input().split()))
ns.sort()
M = int(input())
ms = list(map(int, input().split()))
# for m in ms:
#     print(1 if m in ns else 0)

import bisect
for i in range(M):
    K = bisect.bisect_left(ns, ms[i])
    print(1) if K < N and ns[K] == ms[i] else print(0)
```

## Complexity Analysis
- **Time Complexity**: 문제의 입력 크기와 제한 시간을 고려할 때, 효율적인 알고리즘 선택이 필수적입니다.
- **Space Complexity**: 메모리 제한 내에서 해결할 수 있도록 불필요한 공간 사용을 최소화했습니다.

## Conclusion
문제를 해결하면서 해당 알고리즘에 대한 이해를 높일 수 있었습니다. 다양한 예외 케이스를 고려하는 것이 중요함을 다시 한번 느꼈습니다.

