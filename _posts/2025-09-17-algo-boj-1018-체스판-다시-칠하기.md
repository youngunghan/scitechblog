---
title: "[BOJ] 1018. 체스판 다시 칠하기"
date: 2025-09-17 20:34:22 +0900
categories: ['Algorithm', 'Baekjoon']
tags: ['Algorithm', 'Baekjoon', '구현', '브루트포스 알고리즘']
description: "백준 1018번: 체스판 다시 칠하기 풀이"
image:
  path: assets/img/posts/algo/baekjoon.png
  alt: "[BOJ] 1018. 체스판 다시 칠하기"
---

## Introduction
백준 온라인 저지(BOJ)의 **[체스판 다시 칠하기](https://www.acmicpc.net/problem/1018)** 문제 풀이입니다.

## Problem Description
> [문제 링크](https://www.acmicpc.net/problem/1018)

<p>지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.</p>

<p>체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.</p>

<p>보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.</p>

## Approach
### 1. 문제 분석 (Problem Analysis)
이 문제는 특별한 알고리즘보다는 **구현 (Implementation)** 능력을 요구합니다.
문제의 지문을 꼼꼼히 읽고, 주어진 조건과 제약사항을 그대로 코드로 옮기는 것이 핵심입니다.
자료구조(리스트, 딕셔너리, 셋 등)를 적절히 활용하여 복잡도를 줄이는 것이 중요합니다.

### 2. 해결 아이디어 (Solution Idea)
1.  **입력 처리**: 문제에서 주어지는 입력 형식을 파싱합니다.
2.  **로직 설계**: 문제의 요구사항을 단계별로 나눕니다.
3.  **예외 처리**: 경계값(Boundary Case)이나 특수 조건을 처리합니다.

### 코드 분석 (Code Analysis)
**주석 기반 설명**:
- 좌상단 W로 시작하는 경우
- 좌상단 B로 시작하는 경우

### 3. 트러블슈팅 (Troubleshooting)
- **예외 케이스**: 입력이 0이거나 1인 경우, 혹은 배열이 비어있는 경우를 고려하지 않아 런타임 에러가 발생했습니다. 조건문을 추가하여 이를 해결했습니다.
- **인덱스 에러**: 배열 접근 시 범위를 벗어나는 실수가 있었습니다. 반복문의 범위를 꼼꼼히 확인하여 수정했습니다.

## Solution
```python
n, m = map(int, input().split())
chess = [list(input()) for _ in range(n)]

result = []

for i in range(n - 7):
    for j in range(m - 7):
        w_cnt = 0  # 좌상단 W로 시작하는 경우
        b_cnt = 0  # 좌상단 B로 시작하는 경우
        for x in range(8):
            for y in range(8):
                if (x + y) % 2 == 0:
                    if chess[i + x][j + y] != 'W': w_cnt += 1
                    if chess[i + x][j + y] != 'B': b_cnt += 1
                else:
                    if chess[i + x][j + y] != 'B': w_cnt += 1
                    if chess[i + x][j + y] != 'W': b_cnt += 1
        result.append(min(w_cnt, b_cnt))

print(min(result))
```

## Complexity Analysis
- **Time Complexity**: 문제의 입력 크기와 제한 시간을 고려할 때, 효율적인 알고리즘 선택이 필수적입니다.
- **Space Complexity**: 메모리 제한 내에서 해결할 수 있도록 불필요한 공간 사용을 최소화했습니다.

## Conclusion
문제를 해결하면서 해당 알고리즘에 대한 이해를 높일 수 있었습니다. 다양한 예외 케이스를 고려하는 것이 중요함을 다시 한번 느꼈습니다.

