---
title: "[BOJ] 1018. 체스판 다시 칠하기"
date: 2025-09-17 20:34:22 +0900
categories: ['Algorithm', 'Baekjoon']
tags: ['Algorithm', 'Baekjoon', '구현', '브루트포스 알고리즘']
description: "백준 1018번: 체스판 다시 칠하기 풀이"
image:
  path: assets/img/posts/algo/baekjoon.png
  alt: "[BOJ] 1018. 체스판 다시 칠하기"
math: true
---

## Introduction
백준 온라인 저지(BOJ)의 **[체스판 다시 칠하기](https://www.acmicpc.net/problem/1018)** 문제 풀이입니다.

## Problem Description
> [문제 링크](https://www.acmicpc.net/problem/1018)

<p>지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.</p>

<p>체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.</p>

<p>보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.</p>

## Approach
### 1. 문제 분석 (Problem Analysis)
이 문제는 $M \times N$ 크기의 보드에서 $8 \times 8$ 크기의 체스판을 잘라낼 때, 다시 칠해야 하는 정사각형의 최소 개수를 구하는 문제입니다.
- $N, M$은 최대 50입니다.
- $8 \times 8$ 체스판의 패턴은 두 가지뿐입니다:
    1.  맨 왼쪽 위가 **흰색(W)**인 경우
    2.  맨 왼쪽 위가 **검은색(B)**인 경우
- 가능한 모든 $8 \times 8$ 영역을 잘라내어 두 가지 패턴과 비교해보는 **브루트포스(Brute Force)** 방식으로 해결할 수 있습니다.

### 2. 해결 아이디어 (Solution Idea)
1.  **모든 위치 탐색**: 보드에서 $8 \times 8$ 크기를 잘라낼 수 있는 모든 시작점 $(i, j)$를 순회합니다.
    - $i$는 $0$부터 $N-8$까지, $j$는 $0$부터 $M-8$까지 가능합니다.
2.  **패턴 비교**: 각 시작점에서 $8 \times 8$ 영역을 검사합니다.
    - $(x, y)$ 위치의 색이 체스판 규칙에 맞는지 확인합니다.
    - 체스판 규칙: 행 번호($x$)와 열 번호($y$)의 합이 짝수인지 홀수인지에 따라 색이 결정됩니다.
3.  **최소값 갱신**: 각 영역에서 다시 칠해야 하는 개수 중 최솟값을 구합니다.

### 3. 코드 분석 (Code Analysis)
- 4중 반복문을 사용합니다.
    - 바깥 2중 반복문(`i, j`): $8 \times 8$ 체스판의 시작 위치 결정.
    - 안쪽 2중 반복문(`x, y`): $8 \times 8$ 내부의 각 칸 검사.
- `(x + y) % 2 == 0`인 칸들은 시작점과 같은 색이어야 하고, 그렇지 않은 칸들은 다른 색이어야 합니다.
- `w_cnt`는 시작점이 'W'일 때 다시 칠해야 하는 개수, `b_cnt`는 시작점이 'B'일 때의 개수입니다.

## Solution
```python
import sys

# 입력 받기
input = sys.stdin.readline
n, m = map(int, input().split())
chess = [list(input().strip()) for _ in range(n)]

result = []

# 1. 가능한 모든 8x8 시작점 순회
for i in range(n - 7):
    for j in range(m - 7):
        w_cnt = 0  # 좌상단이 W로 시작하는 체스판으로 만들 때 칠해야 하는 개수
        b_cnt = 0  # 좌상단이 B로 시작하는 체스판으로 만들 때 칠해야 하는 개수
        
        # 2. 8x8 영역 내부 검사
        for x in range(8):
            for y in range(8):
                current_cell = chess[i + x][j + y]
                
                # (x + y)가 짝수이면 시작점과 색이 같아야 함
                if (x + y) % 2 == 0:
                    if current_cell != 'W': w_cnt += 1
                    if current_cell != 'B': b_cnt += 1
                # (x + y)가 홀수이면 시작점과 색이 달라야 함
                else:
                    if current_cell != 'B': w_cnt += 1
                    if current_cell != 'W': b_cnt += 1
                    
        # 3. 두 패턴 중 최소 개수 저장
        result.append(min(w_cnt, b_cnt))

# 전체 중 최솟값 출력
print(min(result))
```

## Complexity Analysis
- **Time Complexity**: $O(NM)$
    - 정확히는 $(N-7)(M-7) \times 64$번의 연산이 수행됩니다.
    - $N, M \le 50$이므로, 최대 약 $43 \times 43 \times 64 \approx 118,336$번의 연산으로 충분히 시간 내에 통과합니다.
- **Space Complexity**: $O(NM)$
    - 입력 보드를 저장하는 공간이 필요합니다.

## Conclusion
브루트포스 알고리즘의 가장 기초적인 문제입니다. 입력 크기가 작을 때($N, M \le 50$)는 모든 경우의 수를 다 확인해보는 것이 가장 확실하고 쉬운 방법임을 상기시켜줍니다.

